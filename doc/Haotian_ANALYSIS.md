CompSci 308: VOOGASalad Analysis
===================

> This is the link to the assignment: [VOOGASalad](http://www.cs.duke.edu/courses/compsci308/current/assign/04_voogasalad/)


Design Review
=======

### Overall Design
Reflect on the coding details of the entire project by reading over all the code.
* Describe the overall design of the complete program(s):
    * What is the high level design of each sub-part and how do they work together (i.e., what behavior, data, or resources does each part depends on from the others)?

        There are five modules, authoring_backend, database, engine, frontend, controller. authoring_backend and frontend are for the authoring engine, while database, engine and controller constitute the game player.

        For authoring engine, authoring_backend holds the data and serialization techniques. It provides getters and setters for the frontend, and these setters and getters automatically handle ID management, path relativization and absolutization, etc. frontend links these setters and getters to GUI components. Data update is done by phase diagrams and node-edge graphs. These all occur in the backend, and frontend has to act as an Observer of the backend components. The Observer pattern is customized because our design dictates that backend has zero JavaFx component for easy data transfer.

    * How is the design tied (or not) to the chosen game genre. What assumptions need to be changed (if anything) to make it handle different genres?

        The design weakens the presence of a controller module in the MVC pattern. This is because in turn based games, we feel a lot of decisions should be deferred to backend as blackbox algorithms and the frontend just has to act as a good observer of the backend module. To handle other genres, we have to make the controller module much more obvious and abstracted out of the middle-end mess. Animations, plots, maps and scrolling pages etc. all require a very strong controller module.

    * What is needed to represent a specific game (such as new code or resources or asset files)?

        Images, sound files and an XML that decides game logic in the same resource directory in the engine module. XML file is generated by the authoring engine, using a language that we implement which is similar to Logisim.

        ![example](https://i.imgur.com/gY8RZ4a.png)

        ![example](https://i.imgur.com/gGMbcy9.png)

* Describe two packages that you did not implement:
    * Which is the most readable (i.e., whose classes and methods do what you expect and whose logic is clear and easy to follow) and give specific examples?

        authoring_backend.conversion is the most readable. This package contains custom XML converters for Xstream that my teammate implement for our own GameObject manager and phase diagram. It's true that we specifically remove all JavaFx components from backend, and Xtream is able to serialize all the backend components using its default converter. However this default serialization does not meet our needs as we do not wish to have an exact copy when we load a game. The classes in the package are very readable.

        ```java
        @Override
        public void marshal(Object o, HierarchicalStreamWriter writer, MarshallingContext ctx) {
            var authTools = (AuthoringTools) o;
            var converters = componentSerializer.getConverterLookup();

            converters.lookupConverterForType(PhaseDB.class).marshal(authTools.phaseDB(), writer, ctx);
            converters.lookupConverterForType(SimpleGameObjectsCRUD.class).marshal(authTools.entityDB(), writer, ctx);

            writer.startNode("gameplay.Turn");

            writer.startNode("myCurrentPhaseName");
            writer.setValue(authTools.phaseDB().getStartingPhase());
            writer.endNode();

            writer.startNode("playersOrder");
            var playerNames = StreamSupport.stream(authTools.entityDB().getPlayerClasses().spliterator(), true)
                    .map(GameObjectClass::getClassName)
                    .collect(Collectors.toList());
            new CollectionConverter(mapper).marshal(playerNames, writer, ctx);

            writer.endNode();

            writer.endNode();
        }
        ```
        This method overrides the default marshal method in Xstream's Converter class. It is clear that this class tries to apply serialization separately to phase diagram and GameObject manager (which is the SimpleGameObjectsCRUD).

        In each converter, there are clear private helper methods written.
        ```java
        private <K, V> String mapToString(Map<K, V> map) {
            String toEval = "[";
            boolean first = true;
            for (var entry : map.entrySet()) {
                if (!first) toEval += ", ";
                else first = false;
                toEval += String.format("%s:%s", entry.getKey(), entry.getValue());
            }
            if (first) toEval += ":";
            toEval += "]";
            return toEval;
        }
        ```
        By doing this, methods such as
        ```java
        for (var player : db.getPlayerClasses()) {
            writer.startNode("gameplay.Player");

            writer.startNode("myName");
            writer.setValue(player.getClassName());
            writer.endNode();

            writer.startNode("myStats");
            var toEval = mapToString(player.getPropertiesMap());
            new MapConverter(mapper).marshal(shell.evaluate(toEval), writer, ctx);
            writer.endNode();

            writer.startNode("myEntityIDs");
            new TreeSetConverter(mapper).marshal(new TreeSet<>(player.getAllGameObjectInstanceIDs()), writer, ctx);
            writer.endNode();

            writer.endNode();
        }
        ```
        are easy to understand.

        The author uses heavy use of lambda expressions which make it easier to follow the logic. Use of generics increase flexibility as well.

        Method naming is intuitive and self explanatory. For example,
        ```java
        private static XStream genAux() {
            var serializer = new XStream(new DomDriver());
            serializer.alias("game-objects", SimpleGameObjectsCRUD.class);
            serializer.alias("phase-info", PhaseDB.class);
            serializer.alias("props", LinkedHashMap.class);

            serializer.registerConverter(new PhaseDBConverter());
            serializer.registerConverter(new PhaseGraphConverter());
            serializer.registerConverter(new BlockGraphConverter());
            serializer.registerConverter(
                    new GameObjectsCRUDConverter(serializer.getMapper())
            );
            return serializer;
        }
        ```
        It's immediately clear that the author is doing a step-by-step serialization. It's easy to debug for a specific component later.

    * Which is the most encapsulated (i.e., with minimal and clear dependencies that are easy to find rather than through "back channels") and give specific examples?

        authoring_backend.gameObjects is the most encapsulated package both internally and externally. It has zero dependency on external modules due to its nature. It essentially provides the GameObject management functionality, which does not depend on any other modules. Other modules depend on it as a service provider. Internally, the classes in this object has very clear APIs written for each class for easy extension and test-driven development.

        The APIs are clearly written. The GameObject manager should provide ID management.
        ```java
        public interface IdManager {
            Consumer<GameObjectClass> requestClassIdFunc();
            Consumer<GameObjectInstance> requestInstanceIdFunc();
            Function<Integer, Boolean> verifyClassIdFunc();
            Function<Integer, Boolean> verifyTileInstanceIdFunc();
        }
        ```
        It is very clear what this ID manager is trying to achieve. The actual implementation of the ID manager is not intuitive, but as a collaborator, that part of harder logic is encapsulated. Just to illustrate, this is part of the actual ID manager,
        ```java
        private int newClassID() {
            return Stream.iterate(1, a -> a + 1).filter(this::notIssuedClassID).findFirst().get();
        }

        private int newInstanceID() {
            return Stream.iterate(1, a -> a + 1).filter(this::notIssuedInstanceID).findFirst().get();
        }

        private boolean notIssuedClassID(int id) {
            return gameObjectClassMap.values()
                    .stream()
                    .noneMatch(c -> c.getClassId() == id);
        }

        private boolean notIssuedInstanceID(int id) {
            return gameObjectInstanceMap.values()
                    .stream()
                    .noneMatch(c -> c.getInstanceId() == id);
        }
        ```

        Another interesting feature of this package by Jason is that it tries to use Consumer and Supplier functional interfaces to increase internal encapsulation. There is a trade-off however, between readability and easiness of coding and encapsulation provided by Consumer and Supplier. Take this class that uses Factory pattern for example,
        ```java
        public EntityInstanceFactory(
                Function<Integer, Boolean> verifyEntityInstanceIdFunc,
                Consumer<GameObjectInstance> requestInstanceIdFunc,
                ThrowingConsumer<GameObjectInstance, InvalidIdException> addInstanceToMapFunc
        ) {
            this.verifyEntityInstanceIdFunc = verifyEntityInstanceIdFunc;
            this.requestInstanceIdFunc = requestInstanceIdFunc;
            this.addInstanceToMapFunc = addInstanceToMapFunc;
        }
        ```
        Encapsulation is probably Jason's top priority when he designed these classes...

* What have you learned about design (either good or bad) by reading your team mates' code?
    * There is a big trade-off between encapsulation and readability and clarity of code, especially using some new Java 8+ features.
    * Divide the work of one class into several different classes as much as possible at the start. Refactoring it later could be hard. The Xstream converter here is spread in to different classes, each class handles one separate task.
    * Use generics more to increase adaptability of code.
    * Write clear interfaces for the classes I write. This is not only good for extensibility, but it makes it easier for collaborators to understand the purpose of my code. Even though an API for frontend is not as straightforward, but I should attempt to do it as much as possible.


### Your Design
Reflect on the coding details of your part of the project.
* Describe how your code is designed at a high level (focus on how the classes relate to each other through behavior (methods) rather than their state (instance variables)).

    My main work is in frontend.api, frontend.authoringInterface and frontend.utils. frontend.api is an earlier development that contains interfaces, however this package is largely unused as I find putting all interfaces in one package is not that helpful. frontend.authoringInterface contains JavaFx components and components that are similar to a controller module in the MVC pattern. Its main purpose is to create the GUI as well as bridges to connect user input with the CRUD manager of the backend. frontend.utils contains some classes that simplify the boiler plate of some JavaFx code. It is a utility package.

* Describe two features that you implemented in detail — one that you feel is good and one that you feel could be improved:
    * Good

        I have a StatusView class that implements UpdateStatusEventListener<Node>. The interface is as follows,
        ```java
        /**
         * This interface is implemented by those (currently only StatusView) that listen to status statistic changes
         *
         * @author Haotian Wang
         */
        public interface UpdateStatusEventListener<T> {
            /**
             * This method specifies what the event listener will do in events occurring.
             *
             * @param view: The parameter to be passed to the EventListener.
             */
            void setOnUpdateStatusEvent(T view);

            /**
             * This method sets up the view of for the batch mode button
             *
             * @param isShiftDown: A boolean passed from other places that indicate whether Shift is being pressed down.
             */
            void setBatchMode(boolean isShiftDown);

            /**
             * This method sets up the view of the delete mode button.
             *
             * @param isControlDown: A boolean passed from other places that indicate whether Control is being pressed down.
             */
            void setDeleteMode(boolean isControlDown);
        }
        ```

        * Justify why the code is designed the way it is or what issues you wrestled with that made the design challenging.

            StatusView is asked to implement a custom event listener because by doing this, the status panel is able to present different information depends on how each class defines an UpdateStatusEvent. It is not limited to show, say the ID of a clicked sprite. Instead it has the power of presenting any information that sends that event. In StatusView, the crucial method is simply written as,
            ```java
            @Override
            public void setOnUpdateStatusEvent(Node view) {
                instanceBox.getChildren().clear();
                instanceBox.getChildren().add(view);
            }
            ```
            In EditGridView, the class updates the StatusView in this line of code,
            ```java
            cell.setOnMouseClicked(e -> listeners.forEach(listener -> listener.setOnUpdateStatusEvent(constructStatusView(cell))));
            ```
            This provides immense flexibility. For example, I can define clicking on some GUI component as sending an UpdateStatusEvent as well and the StatusView will display a help message for the clicked item.
        * Are there any assumptions or dependencies from this code that impact the overall design of the program? If not, how did you hide or remove them?

            This event listener is not implemented fully with a custom EventDispatcher. Essentially all classes that send an UpdateStatusEvent has to have a reference to the UpdateStatusEventListener, which does not encapsulate the listener from the event firing class. In EditGridView, there is an instance variable,
            ```java
            private List<UpdateStatusEventListener<Node>> listeners;

            /**
             * Register the EditGridView with some listener to listen for StatusUpdateEvent changes.
             *
             * @param listener: A listener that listens for UpdateStatusEvents.
             */
            public void addUpdateStatusEventListener(UpdateStatusEventListener<Node> listener) {
                listeners.add(listener);
            }
            ```
            Then in EditView, it uses the proxy pattern to add the listener to EditGridView,
            ```java
            /**
             * This method uses the proxy pattern to pass the registration of listener to the child GridPane.
             *
             * @param listener: The listener to be registered by the child GridPane.
             */
            public void addUpdateStatusEventListener(UpdateStatusEventListener<Node> listener) {
                gridView.addUpdateStatusEventListener(listener);
            }
            ```
            This chain of dependency could be reduced by implementing a full-fledged event dispatcher. Nevertheless, this flaw does not impact the overall design in any way.

    * Bad

        Error handling of GameObject Editors is done in a bad way. The current design does not leverage the Dialog API provided by JavaFx. For example, we have this in AbstractGameObjectEditor,
        ```java
        /**
         * Register the node to Object map.
         *
         * @param node:       The node that is to be altered.
         * @param controller: The NodeInstanceController that controls the relationship between a Node and a GameObjectInstance.
         */
        public void editNode(Node node, NodeInstanceController controller) {
            this.nodeEdited = node;
            editingMode = EditingMode.EDIT_NODE;
            nodeInstanceController = controller;
            try {
                this.gameObjectInstance = controller.getGameObjectInstance(node);
            } catch (NodeNotFoundException ignored) {
            }
            readGameObjectInstance();
            confirm.setOnAction(e -> {
                try {
                    confirmEditNode();
                } catch (IllegalGeometryException e1) {
                    new ErrorWindow("Illegal Geometry", e1.toString()).showAndWait();
                    return;
                } catch (PreviewUnavailableException e1) {
                    new ErrorWindow("Preview Unavailable", e1.toString()).showAndWait();
                    return;
                } catch (UnremovableNodeException e1) {
                    new ErrorWindow("Unremovable Node", e1.toString()).showAndWait();
                    return;
                } catch (GridIndexOutOfBoundsException e1) {
                    new ErrorWindow("Grid IndexOutOfBounds", e1.toString()).showAndWait();
                    return;
                } catch (IllegalGameObjectNamingException e1) {
                    new ErrorWindow("Illegal Naming", e1.toString()).showAndWait();
                    return;
                }
                closeEditor();
            });
        }
        ```
        Compare this error handling design with Amy's editor that changes the size of the grid,
        ```java
        resizeGrid.setOnAction(e -> new ResizeGridView(editView.getGridView().getGridDimension()).showAndWait().ifPresent(
                    dimension -> {
                        updateGridDimension.accept(dimension.getKey(), dimension.getValue());
                        editView.updateDimension(dimension.getKey(), dimension.getValue());
                    }
                )
        );
        ```
        * Justify why the code is designed the way it is or what issues you wrestled with that made the design challenging.

            The main reason is I did not understand JavaFx's Dialog and Alert API clearly before proceeding to implement my own pop-up window. For example, if the user types in an empty name for a new sprite, the editor will correctly display an error message saying that the new sprite cannot have an empty name,
            ```java
            /**
             * This method sets names for GameObjectClass.
             *
             * @return A String name for the GameObjectClass.
             * @throws IllegalGameObjectNamingException
             * @throws DuplicateGameObjectClassException
             */
            String getValidClassName() throws IllegalGameObjectNamingException, DuplicateGameObjectClassException {
                if (nameField.getText().trim().isEmpty()) {
                    throw new IllegalGameObjectNamingException("GameObjectClass cannot have an empty name");
                }
                if(gameObjectClass == null || gameObjectClass.getClassName().equals(nameField.getText().trim())) return nameField.getText().trim();
                try {
                    gameObjectManager.getGameObjectClass(nameField.getText().trim());
                } catch (GameObjectClassNotFoundException e) {
                    return nameField.getText().trim();
                }
                throw new DuplicateGameObjectClassException(nameField.getText().trim() + " already exists, please rename your GameObjectClass");
            }
            ```
            This is correct error handling. However, if the user types in a valid String name and types in some other illegal input (for example entering a non-number String for the height of the object), and clicks apply. The name of the new gameObject will be set, even though not all the inputs are valid. This would create partial objects, which are very hard to track and debug.
            ```java
            /**
             * This method sets up the confirm logic for adding new TreeItems.
             *
             * @throws IllegalGameObjectNamingException
             * @throws IllegalGeometryException
             * @throws PreviewUnavailableException
             * @throws DuplicateGameObjectClassException
             */
            @Override
            protected void confirmAddTreeItem() throws IllegalGameObjectNamingException, IllegalGeometryException, PreviewUnavailableException, DuplicateGameObjectClassException {
                EntityClass entityClass = gameObjectManager.createEntityClass(getValidClassName());
                int width = outputPositiveInteger(widthInput);
                int height = outputPositiveInteger(heightInput);
                assert entityClass != null;
                TreeItem<String> newItem = new TreeItem<>(entityClass.getClassName());
                entityClass.getImagePathList().addAll(imagePaths);
                entityClass.setHeight(height);
                entityClass.setWidth(width);
                ImageView icon = new ImageView(ImageManager.getPreview(entityClass));
                JavaFxOperation.setWidthAndHeight(icon, ICON_WIDTH, ICON_HEIGHT);
                newItem.setGraphic(icon);
                treeItem.getChildren().add(newItem);
                writeClassProperties();
            }
            ```
            The first line will create a new EntityClass even if the rest error handling functions correctly. Compare this to Amy's way of handling editors, it has to go through all error handling before returning a set of variables that can be set to the object or added.
        * Are there any assumptions or dependencies from this code that impact the overall design of the program? If not, how did you hide or remove them?

            The overall design is impacted in the way that objects could be partially created and partially created objects will cause weird bugs. This code depends on NodeInstanceController and CRUD manager also, understandably. It tries not just to read in user input, but also creates the entities in frontend and backend, doing everything at the same time. This could make the system buggy as I don't know which part of it leads to errors when some bugs occur. I will improve this piece of code in masterpiece. It does not encapsulate well as it has references to too many things.


### Flexibility
Reflect on what makes a design flexible and extensible.
* Describe how the project's final API, the one you were most involved with, balances
    * Power (flexibility and helping users to use good design practices) and

        The final API allows the user to add any kind of editors easily. It is extremely easy to add a new kind of node using the Logisim-like graph as well. The packages are named intuitively and easy for the user to add in new toolbars, menus etc. It takes some time to define a new kind of GameObject, though but that is possible.
    * Simplicity (ease of understanding and preventing users from making mistakes)

        Our API is far from easy to understand for the most part. This is a huge area for improvement. In frontend, the controller module is not separated out enough and a new developer could probably easily miss adding some listeners when he/she tries to implement some new feature. The classes are very big, and probably only Amy and I could know what are the things to note when adding a new feature to frontend. Regarding backend, when a new feature is easily added, adjusting serialization and deserialization for that new backend feature is not easy and probably only Inchan can do that. Adding a new GameObject is easy for the developer, but probably only Jason could integrate the newly defined GameObject with the ID management, instance management etc., and only I can make the new GameObject integrate with the frontend. We did not have enough time to make our final API easily understand due to lack of manpower.
* Describe two features that you did not implement in detail — one that you feel is good and one that you feel could be improved:
    * Good

        The node-edge graph that is like a Logisim language that allows the user of the authoring engine to define logic for a turn-based game. This feature has two parts. It has the backend for the graph GUI,
        ```java
        public class SimpleGraph<N extends Node, E extends Edge<N>>
                extends HashMap<N, List<E>> implements Graph<N, E> {
            public SimpleGraph() {
                super();
            }

            @Override
            public void addNode(N n) {
                if (!containsKey(n)) put(n, new ArrayList<>());
            }

            @Override
            public void removeNode(N n) {
                remove(n);
                for (var v : keySet()) get(v).removeIf(e -> e.to() == n);
            }

            @Override
            public void addEdge(E e) throws Throwable {
                addNode(e.from());
                addNode(e.to());
                var tmp = get(e.from());
                tmp.add(e);
                put(e.from(), tmp);
            }

            @Override
            public void removeEdge(E e) {
                for (var v : keySet()) get(v).removeIf(edge -> edge == e);
            }
        }
        ```
        It has the other part that connects the graph with the underlying Groovy code, which heavily uses the factory method. A glimpse of those classes is as follows,
        ```java
        public static Try<GroovyBlock<?>> refBlock(double x, double y, String value, GameObjectsCRUDInterface entityDB) {
            return ValidationUtil.validateReference(value.trim(), entityDB)
                    .map(ref -> new LiteralBlock(x, y, ref, "Ref"));
        }
        ```
        The user does not have to worry about all this and implements a new block easily by adding a method to GameMethods, as blocks will be generated automatically.
        ```java
        public static int randInt(int upperBound) {
            return new Random().nextInt(upperBound);
        }
        ```
        * What is interesting about this code (why did you choose it)?

            This code makes very clever use of generics which increases the generalizability of our node-edge graphs. It is essentially a parser that parses simple Edges and Graphs into very complex Groovy codes that determine logic between every turn of the turn based game. The design is written in a very strong way that the developer just needs to add new methods in GameMethods and the it will be automatically translated in to a block in the authoring engine, with the correct number of ports and error handling. However, it may be a little hard for the developer to understand all these piece together. Therefore, when the developer wants to make some lower-level changes than just creating a custom method, it may be challenging.
        * What classes or resources are required to implement this feature?

            This relies on the external Groovy library and no other resources at all. The classes that are responsible for the backend representation of the graph are in authoring_backend.graph. The coordination of the undirected graphs with actual Groovy blocks are in authoring_backend.groovy. Serialization and deserialization of blocks are in authoring_backend.conversion.engine.BlockGraphConverter. The execution of the block graphs in a game player is in engine/gameplay.GameMethods.
        * Describe the design of this feature in detail (what parts are closed? what implementation details are encapsulated? what assumptions are made? do they limit its flexibility?).

            Technically speaking, very few methods are private in these packages. So technically they are not encapsulated that well, because many methods are public. However, conceptually, many methods can be made package-private such that when the developer wants to define some new blocks, he does not need to worry about how to draw the blocks, how many edges can be connected to the block and how the block will be translated to groovy code. All these are already encapsulated in the authoring_backend module. The user defines a new block in engine module.

            An assumption made in this design is that the user just wants to define simple operations that a standalone Java method could encapsulate, such as generating a random number or checking whether a sudoku is satisfied. Sometimes, the user's block may not be easily abstracted out into a method, especially some logic that involves operations on the JavaFx nodes.
        * How extensible is the design for this feature (is it clear how to extend the code as designed or what kind of change might be hard given this design)?

            Making a new block is extremely easy as demonstrated above. However, making low-level changes poses a significant learning curve for any developer. As I try to understand the design, it's not clear how one part relates to another. Generics provide good type-check, type-cast and generalizability. However, at the same time, the heavy use of generics make it hard for a developer to understand the limit of the current design. For example, look at this code from FunctionBlock,
            ```java
            @Override
            public Try<String> toGroovy(BlockGraph graph) {
                var tryA = graph.findTarget(this, A, true).flatMap(b -> b.toGroovy(graph));
                var tryB = graph.findTarget(this, B, true).flatMap(b -> b.toGroovy(graph));
                var tryC = graph.findTarget(this, C, true).flatMap(b -> b.toGroovy(graph));
                var tryD = graph.findTarget(this, D, true).flatMap(b -> b.toGroovy(graph));
                var tryE = graph.findTarget(this, E, true).flatMap(b -> b.toGroovy(graph));
                var tryOut = graph.findTarget(this, FLOW_OUT).flatMap(b -> b.toGroovy(graph));
                int argCount = count(tryA, tryB, tryC, tryD, tryE);
                if (argN() != DONT_CARE && argCount != argN())
                    return Try.failure(new ArgNumberMismatchException(argN(), argCount));

                return tryA.flatMap(a ->
                        tryB.flatMap(b ->
                                tryC.flatMap(c ->
                                        tryD.flatMap(d ->
                                                tryE.flatMap(e ->
                                                        tryOut.map(out ->
                                                                String.format("%s(%s)%s", op, args(a, b, c, d, e),
                                                                        out.toString().length() > 0 ? ";\n" + out : "")
                                                        )
                                                )
                                        )
                                )
                        )
                );
            }
            ```
            Making low-level changes requires writing code like this, which is not easy to do.
    * Bad

        Previously I said our GameObject manager CRUD has good encapsulation. That is true, but it certainly has many other flaws at the same time, especially in terms of code duplicate. For example, this is from SimpleEntityClass,
        ```java
        @Override
        public boolean addProperty(String propertyName, String defaultValue) {
            if (propertiesMap.containsKey(propertyName)) {
                return false;
            }
            propertiesMap.put(propertyName, defaultValue);
            Collection<EntityInstance> entityInstances = getAllInstances();
            for (EntityInstance e : entityInstances) {
                e.addProperty(propertyName, defaultValue);
            }
            return true;
        }

        @Override
        public boolean removeProperty(String propertyName) {
            if (!propertiesMap.containsKey(propertyName)) {
                return false;
            }
            propertiesMap.remove(propertyName);
            Collection<EntityInstance> entityInstances = getAllInstances();
            for (EntityInstance e : entityInstances) {
                e.removeProperty(propertyName);
            }
            return true;
        }
        ```
        This is from SimpleTileClass,
        ```java
        @Override
        public boolean addProperty(String propertyName, String defaultValue) {
            if (propertiesMap.containsKey(propertyName)) {
                return false;
            }
            propertiesMap.put(propertyName, defaultValue);
            Collection<TileInstance> tileInstances = getAllInstances();
            for (TileInstance t : tileInstances) {
                t.addProperty(propertyName, defaultValue);
            }
            return true;
        }

        @Override
        public boolean removeProperty(String propertyName) {
            if (!propertiesMap.containsKey(propertyName)) {
                return false;
            }
            propertiesMap.remove(propertyName);
            Collection<TileInstance> tileInstances = getAllInstances();
            for (TileInstance t : tileInstances) {
                t.removeProperty(propertyName);
            }
            return true;
        }
        ```
        Polymorphism could definitely be used to improve the code duplicate.
        * What is interesting about this code (why did you choose it)?

            In our current design, we have five kinds of GameObjects, Category, Sound, Player, Tile and Entity. Each GameObject has two interfaces and two classes. For example, for Entity, there are
            * EntityClass (an interface)
            * SimpleEntityClass (a class)
            * EntityInstance (an interface)
            * SimpleEntityInstance (a class)

            Above all there is a GameObjectClass (an interface) and a GameObjectInstance (an interface). This huge amount of interfaces and classes share so many boiler plate code and yet there is some slight variation between each. The parallel class structure influences many other parts of the project because other parts need to cater to each type of class and each type of instance as well. Inside the same package, the CRUD manager has to contain even more duplicate code to handle different kinds of GameObjects, for example,
            ```java
            /**
             * This method is a convenient method that creates different GameObjectClasses, depending on the class name and the gameObjectType.
             *
             * @param gameObjectType : The GameObjectType that determines the type of GameObjectClass that is to be created.
             * @param name           : The name of the GameObjectClass to be created.
             * @return A Subclass of GameObjectClass depending on the String name and the GameObjectType.
             * @throws DuplicateGameObjectClassException
             */
            @SuppressWarnings("unchecked")
            @Override
            public <E extends GameObjectClass> E createGameObjectClass(GameObjectType gameObjectType, String name) throws DuplicateGameObjectClassException {
                switch (gameObjectType) {
                    case CATEGORY:
                        return (E) createCategoryClass(name);
                    case SOUND:
                        return (E) createSoundClass(name);
                    case TILE:
                        return (E) createTileClass(name);
                    case ENTITY:
                        return (E) createEntityClass(name);
                    case UNSPECIFIED:
                        // TODO
                        break;
                    case PLAYER:
                        return (E) createPlayerClass(name);
                }
                return null;
            }
            ```
        * What classes or resources are required to implement this feature?

            No resources are needed, but there are so many classes/instances/interfaces for classes/interfaces for instances that look almost identical that need to be present to implement this feature.
        * Describe the design of this feature in detail (what parts are closed? what implementation details are encapsulated? what assumptions are made? do they limit its flexibility?).

            Closedness is very good in this feature. Not to mention ID management which is completely encapsulated from external modules, internally classes communicate via consumers, suppliers and functions which prevent these huge amount of classes from having references of each other. Jason went so far as,
            ```java
            @Override
            public Function<Integer, Boolean> verifyClassIdFunc() {
                return i -> getClassFromMapFunc.apply(i) != null;
            }
            ```
            However, since using polymorphism is not designed clearly from the start, after adding these obfuscating functional programming stuff, it's even harder to do good polymorphism. It is hard to refactor the code when every variable that gets passed around is actually a Consumer/Supplier... This code works on the assumption that the developer will not add new GameObjects. It is encapsulated, but it is over-engineered so much that it's barely possible to change it. It's a static blackbox.
        * How extensible is the design for this feature (is it clear how to extend the code as designed or what kind of change might be hard given this design)?

            Extensibility is almost zero. For example, when one wants to add a GameObject called Text. He has to add TextClass, SimpleTextClass, TextInstance, SimpleTextInstance and made a lot of additions in the CRUD interface and the SimpleCRUD class, and the ID manager interface and the ID manager class. Not only will there be even more duplicate code, the developer could easily miss adding some methods. Even Jason could easily make mistakes when he tries to work on these children classes of his. Let me give another example,
            ```java
            /**
             * This method is a convenient method that creates concrete GameObjectInstances, depending on the type of GameObjectClass that is passed in or inferred from class name.
             *
             * @param gameObjectClass : The input GameObjectClass.
             * @param topleft         : A Point representing the topleft of the GameObjectInstance deployed.
             * @return A concrete GameObjectInstance inferred from input.
             * @throws GameObjectTypeException
             */
            @SuppressWarnings("unchecked")
            @Override
            public <E extends GameObjectInstance> E createGameObjectInstance(GameObjectClass gameObjectClass, Point topleft) throws GameObjectTypeException {
                switch (gameObjectClass.getType()) {
                    case ENTITY:
                        return (E) createEntityInstance((EntityClass) gameObjectClass, topleft);
                    case PLAYER:
                        // TODO: confirm Player API
                        return (E) createPlayerInstance((PlayerClass) gameObjectClass);
                    case UNSPECIFIED:
                        // TODO
                        break;
                    case TILE:
                        return (E) createTileInstance((TileClass) gameObjectClass, topleft);
                    case SOUND:
                        return (E) createSoundInstance((SoundClass) gameObjectClass);
                    case CATEGORY:
                        return (E) createCategoryInstance((CategoryClass) gameObjectClass);
                }
                return null;
            }
            ```
            Apart from adding an entry to this method, he has to write another createTextInstance method which will very likely look exactly the same as createSomeOtherxxxInstance methods.

### Alternate Designs
Reflect on alternate designs for the project based on your analysis of the current design or project discussions.
* Describe how the original APIs changed over the course of the project and how these changes were discussed and decisions ultimately made.

Original design for the game player is not changed throughout the course. For authoring engine however, the API has changed a lot. Initially we decided to weaken the controller in the MVC pattern, because for a turn based game, it seems everything happens at the backend and the frontend can simply observe the changes that happen in the backend. This is true, but the whole group made the mistake that this rule actually applies to the game player and not the authoring engine. Authoring engine involves many interactions between user input and the backend model, so in the end during actual implementation of the frontend, there are many middle-end elements that should be abstracted out to a separate module. For example, the EntityEditor has a method called readGameObjectInstance that reads in the relevant information of an existing GameObjectInstance,
```java
/**
 * This method brings up an editor that contains the data of an existing object that is already created.
 */
@Override
public void readGameObjectInstance() {
    readInstanceProperties();
    nameField.setText(gameObjectInstance.getInstanceName());
    imagePaths.addAll(gameObjectInstance.getImagePathList());
    widthInput.setText(String.valueOf(gameObjectInstance.getWidth()));
    heightInput.setText(String.valueOf(gameObjectInstance.getHeight()));
    gameObjectManager.getPlayerClasses().forEach(p -> {
        if (p.isOwnedByPlayer(gameObjectInstance)) {
            playerBox.getSelectionModel().select(p);
        }
    });
    Label xLabel = new Label("x, col index");
    Label yLabel = new Label("y, row index");
    colInput = new TextField(String.valueOf(gameObjectInstance.getCoord().getX()));
    rowInput = new TextField(String.valueOf(gameObjectInstance.getCoord().getY()));
    GridPane position = new GridPane();
    position.addRow(0, xLabel, colInput);
    position.addRow(1, yLabel, rowInput);
    position.setHgap(20);
    layout.addRow(6, playerText, playerBox);
    layout.addRow(7, position);
}
```
This is definitely not a case where frontend "observes" the backend. Already this diverges from our original API.
* Describe a design decision discussed about two parts of the program in detail:
    * First
        * What alternate designs were proposed?

            All the frontend modules should observe changes in the backend and the frontend only sends instructions to the backend to modify the GameObjects. Once the backend makes those changes, the various frontend components observe the changes and refresh their contents accordingly. For example, when the user modifies the name of an Entity in the TreeView in the sidebar, frontend sends an instruction to the backend to do some modification at the backend. Then the backend sends some events to the frontend to ask the frontend to update GUIs. For example, the name of the TreeItem should change when the backend changes the name of the GameObject. At the same time, all the GameObjectInstances that are on the Grid should have their classNames changed as well as they all observe the backend String properties.

            Our current design is not like this. The current design works in such a way that a frontend component has to call backend APIs to make changes to the model and also updates other frontend components. For example,
            ```java
            /**
             * Create an instance at a specific Grid cell, which is a Pane from a GameObjectClass
             *
             * @param gameObjectInstance: A GameObjectInstance that is created on the grid.
             * @param cell:               The Pane where an instance will be created.
             */
            private void createInstanceAtGridCell(GameObjectInstance gameObjectInstance, Pane cell) {
                ImageView nodeOnGrid;
                try {
                    nodeOnGrid = new ImageView(ImageManager.getPreview(gameObjectInstance));
                } catch (PreviewUnavailableException e) {
                    ErrorWindow.display("Preview Unavailable", e.toString());
                    return;
                }
                nodeOnGrid.fitHeightProperty().bind(cell.prefHeightProperty().multiply(NODE_TO_CELL_HEIGHT_RATIO));
                nodeOnGrid.fitWidthProperty().bind(cell.prefWidthProperty().multiply(NODE_TO_CELL_WIDTH_RATIO));
                ImageView finalNodeOnGrid = nodeOnGrid;
                cell.getChildren().add(finalNodeOnGrid);
                nodeInstanceController.addLink(finalNodeOnGrid, gameObjectInstance);
                nodeOnGrid.setOnMouseClicked(e -> {
                    if (e.getButton() == MouseButton.SECONDARY) {
                        setUpRightClickMenu(e, finalNodeOnGrid);
                    } else if (e.getButton() == MouseButton.PRIMARY && e.getClickCount() == 1 && isControlDown) {
                        handleClickToRemove(finalNodeOnGrid);
                    } else {
                        handleDoubleClick(e, finalNodeOnGrid);
                    }
                });
                finalNodeOnGrid.setOnDragDetected(e -> {
                    Dragboard db = finalNodeOnGrid.startDragAndDrop(TransferMode.MOVE);
                    ClipboardContent cc = new ClipboardContent();
                    cc.putString(String.valueOf(gameObjectInstance.getInstanceId()));
                    db.setContent(cc);
                    db.setDragView(finalNodeOnGrid.getImage());
                    e.consume();
                });
                int height = 0;
                int width = 0;
                if (gameObjectInstance.getType() == GameObjectType.ENTITY) {
                    height = ((EntityInstance) gameObjectInstance).getHeight();
                    width = ((EntityInstance) gameObjectInstance).getWidth();
                } else if (gameObjectInstance.getType() == GameObjectType.TILE) {
                    height = ((TileInstance) gameObjectInstance).getHeight();
                    width = ((TileInstance) gameObjectInstance).getWidth();
                }
                if (height != 0 && width != 0) {
                    Tooltip.install(finalNodeOnGrid, new Tooltip(String.format("Width: %s\nHeight: %s\nSingle Click to toggle Deletion\nDouble Click or Right Click to edit\nInstance ID: %s\nClass Name: %s", width, height, gameObjectInstance.getInstanceId(), gameObjectInstance.getClassName())));
                }
            }
            ```
            When the user creates a GameObjectInstance on any part of the Grid, the above method is called. It is a very disgusting mix of front end and back end and a new developer could easily mix things up.
        * What are the trade-offs of the design choice (describe the pros and cons of the different designs)?

            The pros of the alternate design is just cleaner code. Frontend observes the same backend and does not try to modify each other. The alternate design is less error-prone too because there is no interdependency between different frontend classes. Our current design suffers from all these flaws. The con of the alternate design is probably implementation difficulty. I am not the one who did backend and I am the only person who does frontend in the first sprint. In the process of getting a basic functional authoring engine, I can hardly manage coding according to the Observer pattern. Also at the time I did not quite understand how events are fired and handled and filtered etc. It's hard to operationalize the observer API.
        * Which would you prefer and why (it does not have to be the one that is currently implemented)?

            I prefer the alternate design by all account.
    * Second
        * What alternate designs were proposed?

            The way that we treated the concept of "grids". It was proposed before that using a 2D array in the backend and a GridPane in the frontend to represent the position of GameObjects are restrictive. They could not handle overlapping objects, hexagonal grids, and 3D extension etc. No practical alternate design was proposed, but it was given as a suggestion to alter our current design.

            Our current design still uses GridPane for the frontend and 2D array for the backend. However we add flexibility of geometry to our project by letting game player interpret these 2D data in their own creative way.
        * What are the trade-offs of the design choice (describe the pros and cons of the different designs)?

            The alternate design is more intuitive as it seems to add flexibility to enable different types of geometry of the landscape of the turn based game. The down side is the implementation difficulty. Our current design defers the task of interpreting 2D array to the game player, so the authoring engine will always present everything in a boring 2D GridPane. Every GameObjectInstance will also occupy only one cell in the GridPane, regardless of how large it actually is. This made it less aesthetically appealing as what the user sees in the authoring engine has nothing to do with what these things look like in the actual game. Using the phase diagram and Groovy block to determine the actual logic is actually more flexible than the alternate design. In GameMethods, we have the following method,
            ```java
            public static boolean hasNoIntersectingEntities(Tile tile) {
                return ENTITIES.values().stream().noneMatch(e -> {
                    boolean verdictX =
                            (tile.getX() <= e.getX() && e.getX() < tile.getX() + tile.getWidth()) ||
                                    (e.getX() <= tile.getX() && tile.getX() < e.getX() + e.getWidth());
                    boolean verdictY =
                            (tile.getY() <= e.getY() && e.getY() < tile.getY() + tile.getHeight()) ||
                                    (e.getY() <= tile.getY() && tile.getY() < e.getY() + e.getHeight());
                    return verdictX && verdictY;
                });
            }
            ```
            This compensates for the loss of flexibility of grid geometry.
        * Which would you prefer and why (it does not have to be the one that is currently implemented)?

            Given the difference in implementation difficulty, I prefer our current design.

### Conclusions
Reflect on what you have learned about designing programs through this project, using any code in the project as examples:
* Describe the best feature of the project's current design and what did you learn from reading or implementing it?

    The best feature of the current design is the encapsulation of backend CRUD manager and GameObject management. I learned the use of Supplier and Consumer much better from that code. I should use more Supplier and Consumer in my own frontend implementation.
* Describe the worst feature that remains in the project's current design and what did you learn from reading or implementing it?

    The worst part is my implementation of event handling and error handling between different frontend modules. Instead of making different frontend components update each other, I should really make frontend components observe the same backend module and update themselves accordingly.
* Consider how your coding perspective and practice has changed during the semester:
    * What is your biggest strength as a coder/designer?

        I actually think in terms of APIs.
    * What is your favorite part of coding/designing?

        To learn from Java's official doc. To see especially event handling and class loading procedures. It's nice to understand how things work and base my model on that more refined understanding.
    * What are two specific things you have done this semester to improve as a programmer this semester?

        * I probably coded the most in all my 308 group projects.
        * I always try to understand everyone's code during the development of each project, given our projects are not monstrously huge. I constantly learn from others and make my code compatible.
