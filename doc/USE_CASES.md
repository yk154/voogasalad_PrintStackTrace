# Use Cases

## Authoring the Game

1. **The user adds an entity to be stored and re-used later**
    In the SideView, the user clicks on the entity's TreeView, and a pop-up window shows up. Inside the window, the user chooses the image and chooses actions of the entity in a check-box.
2. **The user runs the game for testing**
    The users clicks the "Run" button, and the eventListener triggers a new stage that generates the new game based on the .class files created from the backend.
3. **The user wants to save the game that he/she creates**
    The user clicks the "Save" button inside the File tab in the MenuBarView. A FileChooser will appear and the user chooses the location to save the files. The files will be generated by the back end in XML format.
4. **The user drags saved gameObjects from the SideView onto the designing Grid**
    The front end defines an event handler that handles the onDragStart event once the user starts dragging on the entity. Then the Grid defines an onDragEnd event once the mouse stops somewhere on the Grid. These two event handlers store the entity inside a temporary dragging Set, which releases the content upon dropping it on the Grid.
5. **The user clicks on "Run" the game**
    The program will start a new window with a running instance of the developed game and report errors if there are any.
6. **The user clicks on "Redo"**
    The program will implement Momento design. A CareTaker will pass the requested data to Momento, which will resume the data in the Originator
7. **The user clicks on "Undo"**
    The program will implement Momento design. A CareTaker will pass the previous data to Momento, which will return the state of the program to before
8. **The user clicks on "Clear"**
    The previously-entered setting and data will be cleared completely and the author can restart the whole design from scratch.
9. **The user clicks on "Add note"**
    The author can add a text box on a certain position of his/her design to add on comments for his/her design.
10. **The user clicks on "Close"**
    The author can close his/her design and quit the program. The previous design will be auto-saved.
11. **The user clicks on "Help"**
    The user can take a look at the guide in which they learn how to use our program be clicking on the "Help" button.
12. **The user clicks on "Game Example"**
    The user can open the game example file by clicking the "Game Example" button and he/she can get a better idea of how to use our program.
13. **The user wants to open the game that he/she creates**
    The user clicks the “Open” button inside the File tab in the MenuBarView. A FileChooser will appear and the user chooses the files to load. The files should be in XML format.
14. **The user wants to zoom in/out the designing Grid**
    The user can zoom in/out from mouse position at different levels of scaling on the designing Grid.
15. **The author wants to reference an instance of an entity that the player can click on**
    The author refers to the instance with the "$clicked" keyword in the game logic pane. The authoring environment will bind the variable to the instance at runtime.
16. **The author wants to associate some game logic with a certain user-input event**
    The author clicks on the game state and for every valid user-input the author wants to define, he or she provides the logic that is triggered by the input with Groovy code. The logic will be stored in the data file which will be interpreted and executed by the game engine.
17. **The author wants to edit a game he or she previously saved**
    When the author opens the saved file, the back end of the authoring environment reconstructs the back end classes from the serialized data file.
18. **The author wants to add new gameObjects to the game area**
    The author drags and drops the entity icon from the object editor pane. The front end of the game recieves the event and notifies the backend. The backend will create an instance of the entity class and the user can define the entity subsequently.
19. **The author wants to preview the game**
    The author can switch to the preview window. The user can preview few static views of the key ingredients of gameplay.
20. **The user can edit multiple games at the same time**
    By clicking tab add button, the user can open multiple tabs. With multiple tabs, the user can edit multiple games at the same time.
21. **The user wants to attach a picture to an entity**
    Using the object editor pane, the author can select a photo and have the photo as part of the instance variable.
22. **The author wants to add a win condition: Play three specific cards in a row, be able to cancel it in between**
    Within the user input handler pane, the author will set up a state diagram and assign the last arrow some operations the must be executed.
```
> O <-> O -> O -> O
> \ \ <--------/
```
23. **The author wants to make the tiles/gameObjects look different under some certain conditions**
    Within the specific tile/gameObjects editor that pops up when one double clicks on the treeview, one would add more images (indexed incrementally) and write a script that returns an index based on the global/instance variable.
24. **The author wants to attach a specific kind of logic to an entity**
    The EntityView editor panel will have more than options to change pictures, audio etc. It allows user to add/edit the specific logic diagrams between state machines just like the one in the main editor, specifically for this entity.
25. **The author wants to write a three-player card game that has a card that flips the order of turns.**
   The Turn class would have a script that determines which player gets the turn, using values within the global data. The author can set the script so that the order is flipped when "flip" variable within the global data is set to true (the "flip" variable is set within the script that runs when a player plays that card)
26. **The author wants to write a single player game with an AI playingGame against the player.** 
   The author would include the ai code that makes a move within the edge
```
O ---Mouse Clicked (Let's say this ends the player's turn) ---> O
```
27. **The author wants to define different behaviors for each class of gameObjects on a certain user input**
    There's two ways that the author can implement this, either by making a arrow that contains if statements within the execution code to check for the classID, or he/she can setup multiple arrows that rejects all the other classes except for certain classID's within the guard, and execute certain operations specific to those classes. 
28. **The author wants to preview the game**
    The author can switch to the preview window. The user can preview few static views of the key ingredients of gameplay.
## Playing the Game

1. **The player plays a card that skips the next person's turn.**
    The Turn class's currentPlayer can by dynamically set by the Groovy execution code. In this case, its method setPlayer(...) would be called, with the id of the next next player.
2. **The player plays a card that gives them three more moves until it's the next player's turn.**
    The Groovy execution code would check for whether the player has more possible turns--if so, instead of exiting, it reroutes to the start node within the Phase's FSM. 
3. **The player plays a card that reverses the order of turns.**
    The number of players is stored as global data within the Turn class. Instead of incrementing to the id of the next player, the method that chooses the current Player would decrement instead. 
4. **The player, engaged in a game of Tic Tac Toe, gets 3 in a row.**
    The validity check (Groovy code within the Node's event handler) also checks for the win/lose condition. In this case, it calls the Turn class's endGame() method, which will declare the player the winner and end the game. 
5. **The player moves a sprite from one location in the grid to another.**
    Once the validity of this move is checked (is it possible?), the Groovy execution code will change the location (which cell it's on) of the sprite, and the sprite will re-render. 
6. **The user wants to save the game data that she/he played**
    The user clicks the “Save” button inside the File tab in the MenuBarView. A FileChooser will appear and the user chooses the location to save the files. The files will be generated by the back end in XML format.
7. **The player wants to load a previously save game.**
    The user clicks on the load button in the main splash screen and press load. Then the user enters the mode of selecting a bundle of previously saved game files. Then the game is supposed to resume with all the states, media files, scores and number of players.
8. **The player can use a special ability**
    The player clicks on a unit on the screen and ina pop up selects the relevant mode. Then either on the click or when a target is selected some special action is performed. 
9. **The player can remove a sprite**
    The player can through some action, whether it be an attack or dragging one piece over another in chess, cause an entity to be removed from the game
10. **The player can change levels**
    After some objective is completed, the screen will replace the current set of tiles and gameObjects with a new set and the player can keep playing.
11. **An event can occur after a certain number of turns without player prompting**
    It's possible to make some event happen to gameObjects or tiles in the game on some turn based clock.
12. **The player can play against an AI**
    The author can play a game in a single player mode where the computer decides on how to make opposing moves
13. **The player can have allies and enemies**
    In the game the npcs controlled by an AI can either be used to help the user or oppose him or her.


